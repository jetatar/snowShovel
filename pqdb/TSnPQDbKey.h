#ifndef SNS_TSnPQDbKey
#define SNS_TSnPQDbKey

#include "TSnDbKey.h"

class TSnPQConnection;
class TSnPQDbKeyReadWhisperer;
class TSnPQDbKeyWriteWhisperer;


#include <pqxx/version>
namespace pqxx {
   class dbtransaction;
   class result;
   namespace prepare {
#if PQXX_VERSION_MAJOR<4
      class declaration;
#endif
      class invocation;
   };
};


//////////////////////////////////////////////////////////////////////////
//
// TSnPQDbKey
//
// An abstract base class, defining the interface for PostgreSQL database
// keys that interact with the DB using libpqxx.
//
// This base class handles the generic GetFromDb and WriteToDb, but
// uses 3 new functions (required to be defined in derived classes) in
// order to do so.
//
// Two functions, passed on from TSnDbKey, are to be defined:
//    Bool_t IsEqual(const TObject* obj) const
//       - Check if 'obj' is equal to this key. Note the useful function
//         TSnDbKey::IsSameClass to check that obj is the correct type,
//         before casting it up.
//    TString AsString() const
//       - Convert this key to a human-readable string
//
// Three more functions are to be defined:
//    void     GetFromPQDb(pqxx::dbtransaction& trans, pqxx::result& res)
//       - Make the actual SQL statement (be sure to use AddVarToSQL for
//         safety!) and execute it via trans, storing the result in res.
//    TObject* BuildObjFromResult(const pqxx::result& res)
//       - Build an object of some expected type that contains information
//         obtained from the DB upon successful completion of an SQL request.
//    NSnDatabase::EWriteType
//             WriteToPQDb(pqxx::dbtransaction& trans, const TObject& obj)
//       - Make the SQL statement to write the informatiom inside 'obj'
//         to the database via trans. Presumably, the key knows what type
//         of object 'obj' should be and can cast up appropriately. The type
//         of the object should be checked, and the key should determine
//         whether to INSERT or UPDATE based on the contents of the table.
//         The FetchPrimKey function can be used to make this distinction.
//    Bool_t   FetchPrimKey(pqxx::dbtransaction& trans)
//       - Check if the "primary key" is cached (if so, just return kTRUE),
//         if not, fetch it from the database. The primary key is a value
//         or set of values that uniquely identify the row in the DB. Often,
//         this is an integer automatically generated by the DB itself.
//         The TSnPQDbKey should use the minimal amount of information needed
//         to obtain the primary key. For example: with the simple "channel"
//         table, the primary key is the only column (num), so this function
//         could simply check that the desired value exists in the table. For
//         the "component_antenna" table, the primary key is the component_id
//         and it can be fetched using the unique antenna number.
//
//
//////////////////////////////////////////////////////////////////////////

class TSnPQDbKey : public TSnDbKey {
 private:
   Bool_t           fPKcached;// whether the primary key has been cached
   TSnPQConnection* fConn;   // the connection, used to make prepared statements

   static
   void              ThrowOOR(const Char_t* e);
   
 protected:
   TObject*          GetFromDb(TSnDatabase& db);
   NSnDatabase::EWriteType 
                     WriteToDb(TSnDatabase& db, const TObject& obj);
 
   virtual void      GetFromPQDb(pqxx::dbtransaction& trans,
                                 pqxx::result& res)=0;
   virtual NSnDatabase::EWriteType
                     WriteToPQDb(pqxx::dbtransaction& trans,
                                 const TObject& obj)=0;
   virtual TObject*  BuildObjFromResult(const pqxx::result& res)=0;

   // try to get the primary key, to check if the key should be
   // updated or inserted
   virtual Bool_t    FetchPrimKey(pqxx::dbtransaction& trans)=0;
   Bool_t            CheckUniquePrimKey(pqxx::dbtransaction& trans,
                                        const Char_t* keycol,
                                        const Char_t* table);
   
   // keys should use these functions to add variables to an SQL
   // statement. strings will be escaped appropriately; see
   // http://pqxx.org/devprojects/libpqxx/doc/3.1/html/Reference/a00196.html#_details
   template<typename T>
   void AddVarToSQL(const pqxx::dbtransaction& trans,
                    TString& sql, const T var) const;
   void AddVarToSQL(const pqxx::dbtransaction& trans,
                    TString& sql, const TString& var,
                    const Bool_t withQuotes=kTRUE) const;
   void AddVarToSQL(const pqxx::dbtransaction& trans,
                    TString& sql, const Char_t* var,
                    const Bool_t withQuotes=kTRUE) const;
   void AddVarToSQL(const pqxx::dbtransaction& trans,
                    TString& sql, const UChar_t* var,
                    const size_t len) const;

#if PQXX_VERSION_MAJOR<4
   virtual void AddPKToPrepSQL(pqxx::prepare::declaration& pd) const=0;
#endif
   virtual void AddPKValToPrepSQL(pqxx::prepare::invocation& pi) const=0;

   // intentionally not public
   Bool_t            IsPKcached()         const { return fPKcached; }
   void              SetPKcached(const Bool_t c=kTRUE) { fPKcached = c; }
   
 public:
   TSnPQDbKey() : fPKcached(kFALSE), fConn(0) {}
   virtual ~TSnPQDbKey() {}
   
         TSnPQConnection* GetConnection()       { return fConn; }
   const TSnPQConnection* GetConnection() const { return fConn; }
   
   //-- functions so the key can be stored in the cache
   virtual Bool_t        IsEqual(const TObject* obj) const=0;
   virtual TString       AsString() const=0; // convert this key into a string
   
   virtual Bool_t        IsPKvalid() const=0;

   template<typename T>
   static
   UChar_t SafeUChar_cast(const T x) {
      if ( x>=kMaxUChar ) {
         TString s("<TSnPQDbKey::SafeUChar_cast>: Cannot cast [");
         s += x;
         s += "] to UChar_t";
         ThrowOOR(s.Data());
      }
      return static_cast<UChar_t>(x);
   }

   static const Char_t*  GetBoolKeyword(const Bool_t x)
      { return (x ? "TRUE" : "FALSE"); }
   
   friend class TSnPQDbKeyReadWhisperer;
   friend class TSnPQDbKeyWriteWhisperer;
   
   ClassDef(TSnPQDbKey, 1); // ABC for PQXX database keys
};

template<typename T>
inline
void TSnPQDbKey::AddVarToSQL(const pqxx::dbtransaction& trans,
                             TString& sql,
                             const T var) const {
   // add a number to the statement
   sql += var;
}

inline
void TSnPQDbKey::AddVarToSQL(const pqxx::dbtransaction& trans,
                             TString& sql,
                             const TString& var,
                             const Bool_t withQuotes) const {
   // add a string to the statement, possibly with single quotes
   AddVarToSQL(trans, sql, var.Data(), withQuotes);
}

//-- now some interfaces to preserve the encapsulation of the read/write fcns
class TSnPQReadTransactor;
class TSnPQWriteTransactor;

class TSnPQDbKeyReadWhisperer {
   // simple interface to allow only TSnPQReadTransactor access to
   // GetFromPQDb and BuildObjFromResult
   
   static
   void GetFromPQDb(TSnPQDbKey* key,
                    pqxx::dbtransaction& trans, pqxx::result& res) {
      return key->GetFromPQDb(trans, res);
   }
   
   static
   TObject* BuildObjFromResult(TSnPQDbKey* key,
                               const pqxx::result& res) {
      return key->BuildObjFromResult(res);
   }
   
   friend class TSnPQReadTransactor;
   
};

class TSnPQDbKeyWriteWhisperer {
   // simple interface to allow only TSnPQWriteTransactor access to
   // WriteToPQDb
   
   static
     NSnDatabase::EWriteType WriteToPQDb(TSnPQDbKey* key,
                    pqxx::dbtransaction& trans,
		    const TObject& obj) {
      return key->WriteToPQDb(trans, obj);
   }
   
   friend class TSnPQWriteTransactor;
};

#endif // SNS_TSnPQDbKey
