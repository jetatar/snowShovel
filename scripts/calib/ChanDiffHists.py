""" This code creates 3 hisograms for any given root file generated by Corey's pulse timing code. It calculates the difference between channel 0 and the other 3 channels. For all 500 events, it compiles the timing offset in each event from channel 0 into 3 large histograms, one for each channel and its difference from channel 0.
IMPORTANT: The code requires 3 inputs: input file, output file and the threshold. The primarmy function is the last - MakeEventHists - and ought to be called as the following: MakeEventHists(inputfile, outputfile, floor). The input filename needs to be that of an output of the macro 'makeWaves' """

import ROOT, math

EVENTS = 1000
NUMCHANS = 4
INVALID=1000
hists = {}
sample_bins = 800 
sample_min = -2
sample_max = 2


def FindRisingEdge(floor, numevent, file, verbosity = 0):

    """ FindRisingEdge calculates where the rising edge of the pulse is. The 'if' statements involved in the file are used to make sure that extraneous circumstances - pulses beginning in the first bin, or pulses split on either side of the event window - are dealt with accurately """

    left_hand = []

    for j in range(0, NUMCHANS):
        h = file.Get("PedSubWvfms/hPedSubWvfm_ch{chan:02d}_ev{ne:06d}".format(chan=j,ne=numevent))
        hists[j]=h

    for ch,h in hists.iteritems():
        numofbins = h.GetNbinsX()
        X = INVALID
        for k in range(1, numofbins+1):
            amp = h.GetBinContent(k)
            befk = k-1
            x1offset = 0
            if k == 1 : #compensates for pulses that begin in the first bin
                befk = numofbins
                x1offset = numofbins
            if (amp > floor and h.GetBinContent(befk) < floor): #the second parameter avoids the code getting confused with fluctuations in the pulse peak
                x1 = h.GetBinCenter(befk) - x1offset
                x2 = h.GetBinCenter(k)
                y1 = h.GetBinContent(befk)
                y2 = h.GetBinContent(k)
                m = (y2 - y1)  / (x2 - x1)
                if verbosity > 10 :
                    print "ch= ", ch, ": x1=", x1, ";y1=", y1, ";x2 =", x2, ";y2 =",y2, ";m=", m, ";k= ", k
                if (m > 0): #the is statement passes only a positive slope so that the correct risingedge is found
                    X = (floor + m*x1 - y1) / m
                    
                    break
        left_hand.append(X)
    return left_hand

def FindDist(floor, numevent, rootfile):
    
    """ FindDist computes the distance between the 4 channels for any one event"""
    
    dist0 = []
    left_hand = FindRisingEdge(floor, numevent, rootfile)
    if (len(left_hand) != 4) :
        print "Insufficient number of entries ", left_hand
        return None
    else: 
        dist01 = left_hand[0] - left_hand[1]
        dist02 = left_hand[0] - left_hand[2]
        dist03 = left_hand[0] - left_hand[3]
        dist0.append(dist01)
        dist0.append(dist02)
        dist0.append(dist03)
    return dist0

def AllEvents(floor, rootfile):
    
    """AllEvents extends FindDist to all events"""

    ave01 = []
    ave02 = []
    ave03 = []
    for i in range(0, EVENTS):
        dist = FindDist(floor, i, rootfile)
        ave01.append(dist[0])
        ave02.append(dist[1])
        ave03.append(dist[2])
    return (ave01, ave02, ave03)

def outliers(floor, rootfile, xmin):
    
    """ Outliers makes sure that all events are processed correctly - if they aren't then the function will return print statements explaining the error """

    hist = []
    for i in range(0, EVENTS):
        dist = FindDist(floor, i, rootfile)
        if (math.labs(dist[0]) > xmin):
            for j in range(0, NUMCHANS):
                h = file.Get("PedSubWvfms/hPedSubWvfm_ch{chan:02d}_ev{ne:06d}".format(chan=j,ne=i))
                hist.append(h)
                print dist
                FindRisingEdge(floor, i, rootfile, verbosity = 100)
            can1 = ROOT.TCanvas("c1")
            can2 = ROOT.TCanvas("c2")
            can3 = ROOT.TCanvas("c3")        
            can4 = ROOT.TCanvas("c4")
            can1.cd()
            hist[0].Draw()
            can2.cd()
            hist[1].Draw()
            can3.cd()
            hist[2].Draw()
            can4.cd()
            hist[3].Draw()
            break
    return hist

def Hists(floor, rootfile):

    """ Hists creates the three histograms of interest - one for each channel and it's difference from 0 """

    rootfile = ROOT.TFile.Open(rootfile)
    
    ave01, ave02, ave03 = AllEvents(floor, rootfile)
    
    can1 = ROOT.TCanvas("c1")
    can2 = ROOT.TCanvas("c2")
    can3 = ROOT.TCanvas("c3")

    H01 = ROOT.TH1F("h1", "Difference between Channels 0 and 1, threshold {th}; Ch 0 - Ch 1; Number of Events".format(th=floor), sample_bins, sample_min, sample_max)
    H02 = ROOT.TH1F("h2", "Difference between Channels 0 and 2, threshold {th}; Ch 0 - Ch 2; Number of Events".format(th=floor), sample_bins, sample_min, sample_max)
    H03 = ROOT.TH1F("h3", "Difference between Channels 0 and 3, threshold {th}; Ch 0 - Ch 3; Number of Events".format(th=floor), sample_bins, sample_min, sample_max)
    
    for i in range(0, len(ave01)):
        if (ave01[i] != 0 and ave01[i] != INVALID) :
            H01.Fill(ave01[i])
        if (ave02[i] != 0 and ave02[i] != INVALID) :
            H02.Fill(ave02[i])
        if (ave03[i] != 0 and ave03[i] != INVALID) :
            H03.Fill(ave03[i])

    H02.SetLineColor(ROOT.kGreen + 2)
    H03.SetLineColor(ROOT.kMagenta)

    can1.SetLogy()
    can2.SetLogy()
    can3.SetLogy()
    
    can1.cd()
    H01.Draw()
    can2.cd()
    H02.Draw()
    can3.cd()
    H03.Draw()
    
    return [H01, H02, H03]

def MakeEventHists(rootfile, output, floor):
    
    """ Executes Hists and dumps the histograms into a ROOT file """

    hout = Hists(floor, rootfile)
    outf = ROOT.TFile.Open(output, "recreate")
    outf.cd()
    for h in hout:
        h.Write()
    
    return outf, hout
